const puppeteer = require('puppeteer');
const fs = require('fs');
const path = require('path');

// Get collection slugs from our existing data
const collectionImages = require('../src/data/collection-images.json');
const collectionSlugs = Object.keys(collectionImages);

async function scrapeCollection(browser, slug) {
  const page = await browser.newPage();
  const url = `https://catalog.musio.com/${slug}`;
  
  console.log(`  Scraping: ${slug}`);
  
  try {
    await page.goto(url, { waitUntil: 'networkidle2', timeout: 30000 });
    await new Promise(r => setTimeout(r, 2000)); // Wait for JS
    
    const data = await page.evaluate(() => {
      const title = document.querySelector('h1')?.innerText || document.title;
      const instruments = [];
      
      // Find all instrument/articulation items
      document.querySelectorAll('[class*="card"], [class*="item"], li').forEach(el => {
        const text = el.innerText?.trim();
        if (text && text.includes('|') && text.length < 200) {
          instruments.push(text);
        }
      });
      
      return { title, instruments };
    });
    
    await page.close();
    return { slug, ...data };
    
  } catch (error) {
    console.error(`    Error: ${error.message}`);
    await page.close();
    return { slug, title: slug, instruments: [], error: error.message };
  }
}

function parseInstruments(rawData) {
  const allInstruments = [];
  
  rawData.forEach(collection => {
    const collectionName = collection.title.replace(' - Musio', '').trim();
    const slug = collection.slug;
    const seen = new Set();
    
    collection.instruments.forEach(raw => {
      // Parse "Violins I\n\n | \n\nLegato Espressivo" format
      const cleaned = raw.replace(/\n+/g, ' ').replace(/\s+/g, ' ').trim();
      const parts = cleaned.split('|').map(p => p.trim());
      
      if (parts.length === 2) {
        const instrument = parts[0];
        const articulation = parts[1];
        const key = `${instrument}-${articulation}`;
        
        if (!seen.has(key) && instrument && articulation) {
          seen.add(key);
          allInstruments.push({
            collection: collectionName,
            collectionSlug: slug,
            instrument,
            articulation,
            fullName: `${collectionName} - ${instrument} - ${articulation}`
          });
        }
      }
    });
  });
  
  return allInstruments;
}

function generateDataFile(instruments) {
  // Group by collection and instrument for summary
  const byCollection = {};
  instruments.forEach(i => {
    if (!byCollection[i.collectionSlug]) {
      byCollection[i.collectionSlug] = {
        name: i.collection,
        instruments: new Set()
      };
    }
    byCollection[i.collectionSlug].instruments.add(i.instrument);
  });
  
  // Generate TypeScript file
  let ts = `// Complete Musio Instrument Catalog with Articulations
// Auto-generated by Puppeteer scraper
// Total: ${instruments.length} articulations across ${Object.keys(byCollection).length} collections

import { collectionImages } from './collection-images';

export type InstrumentCategory = 
  | 'strings' | 'brass' | 'woodwinds' | 'percussion' | 'keyboards' 
  | 'synths' | 'vocals' | 'world' | 'guitars' | 'bass' | 'orchestral' | 'fx' | 'other';

export type Mood = 
  | 'epic' | 'intimate' | 'dark' | 'bright' | 'mysterious' | 'energetic' 
  | 'melancholic' | 'triumphant' | 'tense' | 'peaceful' | 'aggressive' | 'dreamy' | 'nostalgic' | 'playful';

export type Genre = 
  | 'cinematic' | 'pop' | 'rock' | 'electronic' | 'jazz' | 'classical' 
  | 'ambient' | 'hip-hop' | 'folk' | 'world' | 'r&b' | 'indie' | 'experimental';

export type Role = 'lead' | 'harmony' | 'rhythm' | 'bass' | 'texture' | 'percussion' | 'accent';

export interface Instrument {
  id: string;
  name: string;
  collection: string;
  collectionSlug: string;
  instrument: string;
  articulation: string;
  category: InstrumentCategory;
  moods: Mood[];
  genres: Genre[];
  roles: Role[];
  isPremium: boolean;
  description: string;
  tags: string[];
  color: string;
  imageUrl: string | null;
}

// Category detection based on collection name
function detectCategory(collectionName: string, instrument: string): InstrumentCategory {
  const name = (collectionName + ' ' + instrument).toLowerCase();
  if (name.includes('string') || name.includes('violin') || name.includes('viola') || name.includes('cello') || name.includes('bass') && !name.includes('brass')) return 'strings';
  if (name.includes('brass') || name.includes('horn') || name.includes('trumpet') || name.includes('trombone') || name.includes('tuba')) return 'brass';
  if (name.includes('wind') || name.includes('flute') || name.includes('oboe') || name.includes('clarinet') || name.includes('bassoon')) return 'woodwinds';
  if (name.includes('perc') || name.includes('drum') || name.includes('timpani') || name.includes('cymbal') || name.includes('marimba')) return 'percussion';
  if (name.includes('piano') || name.includes('key') || name.includes('organ') || name.includes('celeste')) return 'keyboards';
  if (name.includes('synth') || name.includes('808') || name.includes('909') || name.includes('machine')) return 'synths';
  if (name.includes('voice') || name.includes('choir') || name.includes('vocal')) return 'vocals';
  if (name.includes('harp')) return 'strings';
  if (name.includes('guitar')) return 'guitars';
  return 'orchestral';
}

// Color by category
function getCategoryColor(category: InstrumentCategory): string {
  const colors: Record<InstrumentCategory, string> = {
    strings: '#C4785A', brass: '#D4A520', woodwinds: '#5A8A7A', percussion: '#B45A5A',
    keyboards: '#4A6A9A', synths: '#8A5AAA', vocals: '#AA6A7A', world: '#9A8A5A',
    guitars: '#8A6A4A', bass: '#4A5A7A', orchestral: '#6A5A4A', fx: '#5A6A8A', other: '#6A6A6A'
  };
  return colors[category];
}

// Generate ID from name
function generateId(collection: string, instrument: string, articulation: string): string {
  return (collection + '-' + instrument + '-' + articulation)
    .toLowerCase()
    .replace(/[^a-z0-9]+/g, '-')
    .replace(/^-|-$/g, '');
}

// All instruments data
const instrumentsRaw = ${JSON.stringify(instruments, null, 2)};

export const instruments: Instrument[] = instrumentsRaw.map(i => {
  const category = detectCategory(i.collection, i.instrument);
  return {
    id: generateId(i.collection, i.instrument, i.articulation),
    name: i.fullName,
    collection: i.collection,
    collectionSlug: i.collectionSlug,
    instrument: i.instrument,
    articulation: i.articulation,
    category,
    moods: ['epic', 'cinematic'] as Mood[],
    genres: ['cinematic', 'classical'] as Genre[],
    roles: ['harmony'] as Role[],
    isPremium: true,
    description: \`\${i.instrument} - \${i.articulation}\`,
    tags: [i.instrument.toLowerCase(), i.articulation.toLowerCase()],
    color: getCategoryColor(category),
    imageUrl: collectionImages[i.collectionSlug] || null
  };
});

export const catalogStats = {
  totalInstruments: instruments.length,
  collections: ${Object.keys(byCollection).length}
};

// Helper functions
export function getInstrumentsByCategory(category: InstrumentCategory) { return instruments.filter(i => i.category === category); }
export function getInstrumentsByCollection(slug: string) { return instruments.filter(i => i.collectionSlug === slug); }
export function getInstrumentsByMood(mood: Mood) { return instruments.filter(i => i.moods.includes(mood)); }
export function getInstrumentsByGenre(genre: Genre) { return instruments.filter(i => i.genres.includes(genre)); }
export function getInstrumentsByRole(role: Role) { return instruments.filter(i => i.roles.includes(role)); }
`;

  return ts;
}

async function main() {
  console.log('ðŸŽµ Full Puppeteer Scrape of Musio Catalog');
  console.log(`   Scraping ${collectionSlugs.length} collections...\n`);
  
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  const rawData = [];
  
  for (let i = 0; i < collectionSlugs.length; i++) {
    const slug = collectionSlugs[i];
    console.log(`[${i + 1}/${collectionSlugs.length}]`);
    const data = await scrapeCollection(browser, slug);
    rawData.push(data);
    console.log(`    Found ${data.instruments.length} items`);
  }
  
  await browser.close();
  
  // Save raw results
  fs.writeFileSync(
    path.join(__dirname, 'full-scrape-raw.json'),
    JSON.stringify(rawData, null, 2)
  );
  
  // Parse and clean
  console.log('\nðŸ“Š Processing data...');
  const instruments = parseInstruments(rawData);
  console.log(`   Extracted ${instruments.length} unique articulations`);
  
  // Generate TypeScript file
  const tsContent = generateDataFile(instruments);
  const outputPath = path.join(__dirname, '../src/data/full-instruments.ts');
  fs.writeFileSync(outputPath, tsContent);
  console.log(`\nâœ… Generated: ${outputPath}`);
  
  // Summary
  console.log('\n=== SUMMARY ===');
  console.log(`Collections scraped: ${collectionSlugs.length}`);
  console.log(`Total articulations: ${instruments.length}`);
}

main().catch(console.error);
